## [1872. Снеговики](https://site.ada.edu.az/~medv/acm/Docs%20e-olimp/Volume%2019/1872.htm)

Зима. 2012 год. На фоне грядущего Апокалипсиса и конца света незамеченной прошла новость об очередном прорыве в областях клонирования и снеговиков: клонирования снеговиков. Вы конечно знаете, но мы вам напомним, что снеговик состоит из нуля или более вертикально поставленных друг на друга шаров, а клонирование — это процесс создания идентичной копии (клона).

В городе Местячково учитель Андрей Сергеевич Учитель купил через интернет-магазин "Интернет-магазин аппаратов клонирования" аппарат для клонирования снеговиков. Теперь дети могут играть и даже играют во дворе в следующую игру. Время от времени один из них выбирает понравившегося снеговика, клонирует его и:

·        либо добавляет ему сверху один шар;
·        либо удаляет из него верхний шар (если снеговик не пустой).

Учитель Андрей Сергеевич Учитель записал последовательность действий и теперь хочет узнать суммарную массу всех построенных снеговиков.

**Вход.**  Первая строка содержит количество действий _n_ (1 ≤ _n_ ≤ 200000). В строке номер _i_ + 1 содержится описание действия:

`t m` – клонировать снеговика номер _t_ (0 ≤ _t_ < _i_) и добавить сверху шар массой _m_ (0 < _m_ ≤ 1000);

`t 0` — клонировать снеговика номер _t_ (0 ≤ _t_ < _i_) и удалить верхний шар. Гарантируется, что снеговик не пустой.

В результате действия _i_, описанного в строке _i_ + 1 создается снеговик номер _i_. Изначально имеется пустой снеговик с номером ноль.

Все входные числа целые.

**Выход.** Выведите суммарную массу построенных снеговиков.

| **Пример входа**                                          | **Пример выхода** |
| --------------------------------------------------------- | ----------------- |
| 8<br>0 1<br>1 5<br>2 4<br>3 2<br>4 3<br>5 0<br>6 6<br>1 0 | 74                |

## РЕШЕНИЕ

**структуры данных - стек**

# Анализ алгоритма

Информацию о снеговиках будем хранить в векторе структур Man. Структура Man содержит массу снеговика, а также номер его предка – номер снеговика, который был клонирован для его получения.

·        Если _i_-ый снеговик получается из _t_-го (_t_ < _i_) добавлением шара снега массой _m_, то в v[_i_] заносим снеговика с параметрами Man(v[_t_]._Weight_ + _m_, _t_).

·        Если _i_-ый снеговик получается из _t_-го (_t_ < _i_) удалением верхнего шара, то получится снеговик, из которого был клонирован _t_-ый (номер снеговика, из которого был получен _t_-ый, содержится в v[_t_]._Parent_). То есть v[_i_] следует положить равным v[v[_t_]._Parent_].

Считаем, что нулевой снеговик получен сам из себя и имеет массу 0. То есть значению v[0] присвоим снеговика Man(0, 0).

**Пример**

Рассмотрим приведенный в примере процесс клонирования снеговиков. Сверху над каждым снеговиком приведена его масса.

![](https://site.ada.edu.az/~medv/acm/Docs%20e-olimp/Volume%2019/1872.files/image002.gif)

Шестой снеговик получается из пятого удалением верхнего шара. Следовательно он должен совпадать с четвертым снеговиком (из которого получился пятый). Но поскольку четвертый снеговик получен из третьего добавлением шара, то можно рассматривать шестого снеговика как такового, который получен из третьего добавлением шара с массой 2.

Восьмой снеговик получается из первого удалением верхнего шара. Он станет равным нулевому снеговику. Но поскольку считается, что нулевой снеговик получается из нулевого, то восьмой снеговик считается образованным из нулевого.

# Реализация алгоритма

Объявим вектор пар v, в котором будем хранить информацию о снеговиках.

```cpp

struct Man

{

  int Weight;

  int Parent;

  Man(int Weight, int Parent) : Weight(Weight), Parent(Parent) {};

};

vector<Man> v;
```
Моделируем процесс создания снеговиков как описано в анализе задачи.
```cpp
scanf("%d",&n); sum = 0;

v.push_back(Man(0,0));

for(i = 1; i <= n; i++)

{

  scanf("%d %d",&t,&m); 

  if (m > 0) v.push_back(Man(v[t].Weight + m, t));

  else v.push_back(v[v[t].Parent]);

  sum += v[i].Weight;

}
```
Выводим искомую суммарную массу снеговиков.
```cpp
printf("%lld\n",sum);
```
**Реализация при помощи с****татического массива**
```cpp
#include <stdio.h>

struct Pair

{
  int Number;
  int Weight;
} Sman[200001];

int i, n, t, m;
long long sum;

int main(void) {
  scanf("%d",&n); sum = 0;
  for(i = 1; i <= n; i++) {
    scanf("%d %d", &t, &m); 
    if (m > 0) {
      Sman[i].Number = t;
      Sman[i].Weight = Sman[t].Weight + m;
    }
    else Sman[i] = Sman[Sman[t].Number];

    sum += Sman[i].Weight;
  }

  printf("%lld\n",sum);

  return 0;

}
```
**Python реализация**

```py
n = int(input())

parents = [0]
weights = [0]

for i in range(n):
	t, m = map(int, input().split())
	if m:
		parents.append(t)
		weights.append(weights[t] + m)
	else:
		pt = parents[t]
		parents.append(parents[pt])
		weights.append(weights[pt])

print(sum(weights))
```
