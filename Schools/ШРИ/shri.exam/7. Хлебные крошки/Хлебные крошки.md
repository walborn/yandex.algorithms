Разработчики решили написать очень полную документацию. А по-настоящему большая документация требует хорошей навигации, и хлебные крошки — то, что надо. Чтобы не сковывать себя рамками h1-h6 тегов, было решено использовать div с атрибутом data-header, который может принимать любые значения, соответствующие натуральным числам (число в атрибуте data-header обозначает вложенность заголовка). Чтобы не слушать каждое событие скролла, используется IntersectionObserver. Необходимо написать функцию, которая возвратит колбек для этого observer.

Хлебные крошки отражают позицию в документе, от корня, до текущего заголовка (пробегая по всем промежуточным уровням заголовков)

Текущий заголовок:

Видимый заголовок, у которого не видны подзаголовки или их не существует. Иначе говоря, заголовок самого высокого уровня из тех, что видны во вьюпорте.
Если таких несколько, то из них текущий — первый по порядку
Если во вьюпорте вообще нет заголовков, то текущий — максимально близкий невидимый сверху. Ведь мы находимся как раз в той "главе", которой и дан заголовок.
[./markdown-image.png](./markdown-image.png)
Условия
Заголовки имеют вид <div data-header="2" id="install">installation</div>
У каждого заголовка есть уникальный id
Хлебные крошки выглядят как список ссылок на заголовки, ссылки разделены косой чертой
Хлебные крошки выводятся в элементе header, но вручную их обновлять не нужно, дана функция обновления updateBreadcrumbs, её и нужно использовать
updateBreadcrumbs принимает массив id, хлебные крошки будут отрисованы в соответствующем порядке
Менять DOM нельзя, кроме как вызывать updateBreadcrumbs
Решение должно представлять из себя файл, в котором экспортируется единственная синхронная! функция getObserverCallback, которая в качестве аргумента принимает updateBreadcrumbs

// solution.js

// на уровне модуля можно писать код, но импортироваться будет только getObserverCallback

export function getObserverCallback(updateBreadcrumbs) {
    // решение
}
Функция будет вызвана примерно так (см. main.js файл в zip архиве ниже по ссылке "скачать условие задачи")

// main.js

function updateBreadcrumbs(idList) {
    // некое превращение string[] в список ссылок и обновление header
}

document.addEventListener('DOMContentLoaded', () => {
    // ваша функция вызывается
    const callback = getObserverCallback(updateBreadcrumbs);

    // создаётся обсервер
    const intersectionObserver = new IntersectionObserver(callback);

    // он следит за "заголовками"
    document.querySelectorAll('div[data-header]').forEach(el => intersectionObserver.observe(el));
});
Примечания
Ограничения:

Максимальное количество заголовков 10^6
Максимальное количество уровней вложенности 10^4
Максимальное количество видимых одновременно заголовков 100
Функция getObserverCallback должна выполнится не более чем за секунду
callback должен отрабатывать не более чем за 10 миллисекунд, начиная со второго срабатывания (исключая первоначальное событие со всем заголовками)